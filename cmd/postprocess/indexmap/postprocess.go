package main

import (
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

// SwaggerSpec is a minimal representation of your OpenAPI spec,
// assuming definitions are under the "definitions" key.
type SwaggerSpec struct {
	Definitions map[string]Definition `yaml:"definitions"`
}

// Definition represents a model definition.
// We capture all keys inline and extract vendor extensions.
type Definition struct {
	Raw              map[string]interface{} `yaml:",inline"`
	VendorExtensions map[string]interface{}
}

// UnmarshalYAML customizes the unmarshaling to extract vendor extensions.
func (d *Definition) UnmarshalYAML(value *yaml.Node) error {
	var raw map[string]interface{}
	if err := value.Decode(&raw); err != nil {
		return err
	}
	d.Raw = raw
	d.VendorExtensions = make(map[string]interface{})
	for k, v := range raw {
		if strings.HasPrefix(k, "x-") {
			d.VendorExtensions[k] = v
		}
	}
	return nil
}

const tmplText = `// Code generated by postprocess tool; DO NOT EDIT.

package models

import (
	"github.com/suparena/storage/registry"
	"github.com/aws/aws-sdk-go-v2/feature/dynamodb/attributevalue"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb/types"
)

func init() {
{{- range $modelName, $def := . }}
    {{- $ixMap := index $def.VendorExtensions "x-dynamodb-indexmap" }}
    {{- if $ixMap }}
    // Register index map for model {{$modelName}}
    registry.RegisterIndexMap[{{$modelName}}](func() map[string]string {
        // Extract index map details from the vendor extension.
        return map[string]string{
            {{- range $key, $value := $ixMap }}
            "{{$key}}": "{{$value}}",
            {{- end }}
        }
    }())
    {{- end }}
    // Register type registry for model {{$modelName}}.
    // The registry key is the model name (which is also injected as the EntityType when persisting).
    registry.RegisterType("{{$modelName}}", func(item map[string]types.AttributeValue) (interface{}, error) {
        obj := &{{$modelName}}{}
        err := attributevalue.UnmarshalMap(item, obj)
        return obj, err
    })
{{- end }}
}
`

func main() {
	// Command-line flags: input OpenAPI spec and output file.
	inputFile := flag.String("in", "openapi.yaml", "Path to the OpenAPI spec YAML file")
	outputFile := flag.String("outputdata", "indexmap_type_registry_registration.go", "Path for the generated registration code")
	flag.Parse()

	// Read the OpenAPI spec.
	data, err := ioutil.ReadFile(*inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input file: %v\n", err)
		os.Exit(1)
	}

	// Unmarshal YAML into our SwaggerSpec structure.
	var spec SwaggerSpec
	if err := yaml.Unmarshal(data, &spec); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	// Filter definitions: keep only those that have the x-dynamodb-indexmap extension.
	filtered := make(map[string]Definition)
	for name, def := range spec.Definitions {
		if _, ok := def.VendorExtensions["x-dynamodb-indexmap"]; ok {
			filtered[name] = def
		}
	}

	// Parse and execute the template.
	t, err := template.New("registration").Parse(tmplText)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing template: %v\n", err)
		os.Exit(1)
	}

	outFile, err := os.Create(*outputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error creating output file: %v\n", err)
		os.Exit(1)
	}
	defer outFile.Close()

	if err := t.Execute(outFile, filtered); err != nil {
		fmt.Fprintf(os.Stderr, "Error executing template: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Generated %s successfully.\n", *outputFile)
}
